<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>耀敬业的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="耀敬业的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="耀敬业的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="耀敬业的博客">
  
    <link rel="alternate" href="/atom.xml" title="耀敬业的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">耀敬业的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2018-08-24-算法之常用数据结构" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/24/2018-08-24-算法之常用数据结构/" class="article-date">
  <time datetime="2018-08-23T16:00:00.000Z" itemprop="datePublished">2018-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/24/2018-08-24-算法之常用数据结构/">算法之常用数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="算法之常用数据结构"><a href="#算法之常用数据结构" class="headerlink" title="算法之常用数据结构"></a>算法之常用数据结构</h1><h2 id="通用数据结构"><a href="#通用数据结构" class="headerlink" title="通用数据结构"></a>通用数据结构</h2><p>可简单地按照速度将通用数据结构划分为: <strong>数组</strong>和<strong>链表</strong>(最慢)、<strong>树</strong>(较快)、<strong>哈希表</strong>(最快).<br><strong>增、删、改、查</strong>是四大常见操作, 可浓缩为两个操作:增和查.<br>删除操作和修改操作都是建立在查找操作上的, 所以完美的数据结构应该是具有较高的插入效率和查找效率.</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>数组在以下三个情形很有用:</p>
<ul>
<li>数据量小</li>
<li>数据规模已知</li>
<li>随机访问, 修改元素值</li>
</ul>
<p>如果插入速度很重要, 选择无序数组. 如果查找速度很重要, 选择有序数组, 并使用二分查找.</p>
<p><strong>缺点</strong></p>
<ul>
<li>需要预知数据规模</li>
<li>插入效率低, 因为需要移动大量元素</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>链表是一种物理存储单元上非连续、非顺序的存储结构, 数据元素的逻辑顺序是通过链表中的指针链接次序实现的. 链表由一系列结点(链表中每一个元素都称为结点)组成, 结点可以在运作时动态生成. 每个结点包括两个部分: 一个存储数据元素的数据域, 另一个存储存储下一个结点的指针域. 相比于线性表顺序结构, 操作复杂. 由于不必要按顺序存储, 链表在插入的时候可以达到<code>O(1)</code>的复杂度, 比另一种线性顺序表快得多, 但是查找一个节点或者访问特定编号的节点则需要<code>O(n)</code>的时间, 而线性表和顺序表相应的时间复杂度分别是<code>O(logn)</code>和<code>O(1)</code>.</p>
</blockquote>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>链表的出现解决了数组的两个问题:</p>
<ul>
<li>需要预知数据规模</li>
<li>插入效率低</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>数据量小</li>
<li>不需要预知数据规模</li>
<li>适用于频繁的插入操作</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>有序数组可以通过二分查找方法具有很高的查找效率(<code>O(logn)</code>), 二链表只能使用顺序查找, 效率低于(<code>O(n)</code>).</li>
</ul>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h3 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h3><ul>
<li>有序数组具有较高的查找效率(<code>O(logn)</code>), 而链表具有较高的插入效率(<code>头插法, O(1)</code>), 结合这两种数据结构, 创建一种貌似完美的数据结构, 也就是二叉查找树.</li>
</ul>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>数据是随机分布的</li>
<li>数据量较大</li>
<li><p>频繁的查找和插入操作(可以提供<code>O(logn)</code>级的查找、插入和删除操作);</p>
<p><strong>缺点</strong></p>
<p>如果处理的数据是有序的(升序/降序), 那么构造的二叉查找树就会只左子树(或右子树), 也就是退化为链表, 查找效率低下(<code>O(logn)</code>).</p>
</li>
</ul>
<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><h3 id="解决的问题-2"><a href="#解决的问题-2" class="headerlink" title="解决的问题"></a>解决的问题</h3><p> 针对二叉查找树可能会退化为链表的情况, 提出了平衡树, 平衡树要求任意节点的左右两个子树的高度差不超过1, 避免退化为链表的情况.</p>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>无论数据分布是否随机都可以提供<code>O(logn)</code>级别的查找、插入和删除效率</li>
<li><p>数据量较大</p>
<p><strong>缺点</strong></p>
</li>
<li>平衡树的实现过于复杂.</li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="解决的问题-3"><a href="#解决的问题-3" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>同平衡树一样, 哈希表也不要求数据分布是否随机, 不过哈希表的实现比平衡树要简单得多.</p>
<h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>不要求对最大最小值存取</li>
<li>无论数据分布是否随机, 理想情况下(无冲突)可以提供<code>O(1)</code>级别的插入、查找和删除效率.</li>
<li>数据量大</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于是基于数组的, 数组(哈希表)创建难以拓展, 使用开发地址法的哈希表在基本被填满时, 性能下降的非常严重.</li>
<li>不能对最大最小值存取</li>
</ul>
<h2 id="专用数据结构"><a href="#专用数据结构" class="headerlink" title="专用数据结构"></a>专用数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p><strong>优点</strong></p>
<ul>
<li>在输入数据量可预知的情形下, 可以使用数组实现栈, 并且数组实现的栈效率更高, 出栈和入栈操作都是在数组末尾完成.</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>如果对数组大小创建不当, 可能会产生栈溢出的情况</li>
</ul>
<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><p><strong>优点</strong></p>
<ul>
<li>不会发生栈溢出的情况</li>
<li>输入数据量未知时, 使用栈链. 通过头插法实现入栈操作, 头删法实现出栈操作. 出栈和入栈均是<code>O(1)</code>.</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于入栈时, 首先要创建插入的节点, 要向操作系统申请内存, 所以链栈没有顺序栈效率高.</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/lz3018/p/5932198.html" target="_blank" rel="noopener">常见数据结构应用场景</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/24/2018-08-24-算法之常用数据结构/" data-id="cjoquoco50005ij44wzqlrjkt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-08-23-金钱精度失真问题及解决" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/23/2018-08-23-金钱精度失真问题及解决/" class="article-date">
  <time datetime="2018-08-22T16:00:00.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/23/2018-08-23-金钱精度失真问题及解决/">金钱数值精度失真及解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="金钱数值精度失真及解决方案"><a href="#金钱数值精度失真及解决方案" class="headerlink" title="金钱数值精度失真及解决方案"></a>金钱数值精度失真及解决方案</h1><h2 id="1-问题所在"><a href="#1-问题所在" class="headerlink" title="1.问题所在"></a>1.问题所在</h2><p>在进行金钱运算时, 如:加、减、比较大小等运算时, 如果进行运算的两个数是CGFloat浮点型时, 如两个数都为1.20 和 1.20, 可能前一个在比较的时候就会变为1.2000000001 或者为 1.199999999, 当进行比较的时候 失真的1.20变为1.199999999与1.20比较时就会导致解决出错.注入此类的问题, 会导致金钱结算出现错误.</p>
<p>例1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CGFloat c = 0.02;</span><br><span class="line">   CGFloat a = 1.20 * 3 + c;</span><br><span class="line">   CGFloat b = 3.62;</span><br><span class="line">   </span><br><span class="line">   if (a &gt; b) &#123;</span><br><span class="line">       NSLog(@&quot;a &gt; b&quot;);</span><br><span class="line">   &#125;else if (a &lt; b)&#123;</span><br><span class="line">       NSLog(@&quot;b &gt; a&quot;);</span><br><span class="line">   &#125;else if (a == b)&#123;</span><br><span class="line">       NSLog(@&quot;a == b&quot;);</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       NSLog(@&quot;error&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><img src="/img/数值精度/2018-08-23-01.png" alt="1"></p>
<p><img src="/img/数值精度/2018-08-23-02.png" alt="2"></p>
<p>很明显 a 经过运算后已经失真为3.6199999999999997, b失真为3.6200000000000001, a 与 b 比较为 b&gt;a, 这个结果并不是我们想要的结果, 我们期待的结果是 a==b, 那么我们要怎么才能解决这个问题呢?</p>
<h2 id="2-方案"><a href="#2-方案" class="headerlink" title="2.方案"></a>2.方案</h2><p>为了解决浮点型数据失真的问题, 苹果给出的NSDecimalNumber类可以解决这个问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//初始化 NSDecimalNumber</span><br><span class="line">+ (NSDecimalNumber *)decimalNumberWithString:(nullable NSString *)numberValue;</span><br><span class="line"></span><br><span class="line">//加分运算</span><br><span class="line">- (NSDecimalNumber *)decimalNumberByAdding:(NSDecimalNumber *)decimalNumber;</span><br><span class="line"></span><br><span class="line">//减法运算</span><br><span class="line">- (NSDecimalNumber *)decimalNumberBySubtracting:(NSDecimalNumber *)decimalNumber;</span><br><span class="line"></span><br><span class="line">//乘法运算</span><br><span class="line">- (NSDecimalNumber *)decimalNumberByMultiplyingBy:(NSDecimalNumber *)decimalNumber;</span><br><span class="line"></span><br><span class="line">//除法运算</span><br><span class="line">- (NSDecimalNumber *)decimalNumberByDividingBy:(NSDecimalNumber *)decimalNumber;</span><br><span class="line"></span><br><span class="line">//比较</span><br><span class="line">- (NSComparisonResult)compare:(NSNumber *)decimalNumber;</span><br></pre></td></tr></table></figure>
<p>例2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CGFloat e = 1.20;</span><br><span class="line">  CGFloat d = 3.0;</span><br><span class="line">  CGFloat c = 0.02;</span><br><span class="line">  CGFloat a = e * d + c;</span><br><span class="line">  CGFloat b = 3.62;</span><br><span class="line">  </span><br><span class="line">  NSDecimalNumber *cN = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%0.2f&quot;, c]];</span><br><span class="line">  NSDecimalNumber *dN = [NSDecimalNumber decimalNumberWithString:@&quot;3.0&quot;];</span><br><span class="line">  NSDecimalNumber *eN = [NSDecimalNumber decimalNumberWithString:@&quot;1.20&quot;];</span><br><span class="line">  NSDecimalNumber *aN = [eN decimalNumberByMultiplyingBy:dN];</span><br><span class="line">  aN = [aN decimalNumberByAdding:cN];</span><br><span class="line">  NSDecimalNumber *bN = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%0.2f&quot;, b]];</span><br><span class="line">  </span><br><span class="line">  if ([aN compare:bN] == NSOrderedDescending) &#123;</span><br><span class="line">      NSLog(@&quot;a &gt; b&quot;);</span><br><span class="line">  &#125;else if ([aN compare:bN] == NSOrderedAscending)&#123;</span><br><span class="line">      NSLog(@&quot;b &gt; a&quot;);</span><br><span class="line">  &#125;else if ([aN compare:bN] == NSOrderedSame)&#123;</span><br><span class="line">      NSLog(@&quot;a == b&quot;);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">      NSLog(@&quot;error&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><img src="/img/数值精度/2018-08-23-04.png" alt=""></p>
<p>从上面的结果我们可以看出运用NSDecimalNumber得出的aN 和 bN确实解决了数值精度的问题.</p>
<h2 id="附"><a href="#附" class="headerlink" title="附:"></a>附:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSComparisonResult)compare:(NSNumber *)decimalNumber;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, NSComparisonResult) &#123;NSOrderedAscending = -1L, NSOrderedSame, NSOrderedDescending&#125;;</span><br></pre></td></tr></table></figure>
<p>比较的结果有三种情况:</p>
<blockquote>
<ol>
<li>NSOrderedAscending(升序)</li>
<li>NSOrderedSame(相等)</li>
<li>NSOrderedDescending(降序)</li>
</ol>
</blockquote>
<p>NSOrderedAscending: 升序, 右边的数值比左边的大为升序<br>NSOrderedSame: 相等, 左右两边的数值一样大<br>NSOrderedDescending: 降序, 右边数值比左边的小为降序</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/23/2018-08-23-金钱精度失真问题及解决/" data-id="cjoquocnz0001ij44zij7efo2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-03-23-苹果官方文档阅读入门" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/23/2018-03-23-苹果官方文档阅读入门/" class="article-date">
  <time datetime="2018-03-22T16:00:00.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/2018-03-23-苹果官方文档阅读入门/">苹果官方文档阅读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="苹果官方文档阅读"><a href="#苹果官方文档阅读" class="headerlink" title="苹果官方文档阅读"></a>苹果官方文档阅读</h1><p>1.<a href="https://developer.apple.com/library/content/navigation/" target="_blank" rel="noopener">苹果官方文档</a>的的文档架构</p>
<p><strong>Resource Type</strong>，也就是资源类型，下面是这个类型的子目录介绍</p>
<ol>
<li>Guides —指南</li>
<li>Release Notes —发布说明</li>
<li>Sample Code —实例代码</li>
<li>Technical Notes —技术说明</li>
<li>Technical Q&amp;A —常见技术文答</li>
</ol>
<p><strong>Topic</strong></p>
<ol>
<li>Audio &amp; Video — 音视频</li>
<li>Language &amp; Utilties — 语言和工具</li>
<li>Mathematical computation — 数学计算</li>
<li>Xcode — 介绍xcode的使用</li>
<li>Data management — 数据管理</li>
<li>General — 一般性的问题</li>
<li>Graphics &amp; Animation — 图形和动画</li>
<li>Networking &amp; Internet — 网络问题</li>
<li>Security — 安全问题</li>
<li>Performance — 性能</li>
<li>User experience — 用户体验</li>
<li>Swift — 新出的Swift语言</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/23/2018-03-23-苹果官方文档阅读入门/" data-id="cjoquocnt0000ij445b3fegz1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-03-23-谈谈KVO的实现原理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/23/2018-03-23-谈谈KVO的实现原理/" class="article-date">
  <time datetime="2018-03-22T16:00:00.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/2018-03-23-谈谈KVO的实现原理/">KVO的实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="KVO的实现原理"><a href="#KVO的实现原理" class="headerlink" title="KVO的实现原理"></a>KVO的实现原理</h1><h2 id="1-KVO是什么？"><a href="#1-KVO是什么？" class="headerlink" title="1.KVO是什么？"></a>1.KVO是什么？</h2><p>KVO是Objective-C对观察者模式的一种实现。</p>
<p>KVO提供一种机制，指定一个被观察对象（例如A类），当对象的某个属性（例如A中的字符串name）发生改变时，对象会获得通知，并作出处理。【且不需要给被观察的对象添加任何额外代码，就能使用KVO机制】</p>
<h2 id="2-实现原理？"><a href="#2-实现原理？" class="headerlink" title="2. 实现原理？"></a>2. 实现原理？</h2><p>KVO在Apple中的API文档如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Automatic key-value observing is implemented using a technique called isa-swizzling.. </span><br><span class="line">When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, </span><br><span class="line">pointing to an intermediate class rather than at the true class..</span><br></pre></td></tr></table></figure>
<p><strong>基本原理：</strong></p>
<p>当观察某个对象A时，KVO机制动态创建一个对象A当前类的子类，并为这个新建的子类重写了被观察属性keyPath的setter方法。setter方法随后负责通知观察对象属性的变化状况。</p>
<p><strong>深入剖析：</strong></p>
<p>Apple 使用了isa混写（isa-swizzling）来实现KVO。当观察对象A，KVO机制会动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter方法，setter方法负责调用原setter方法之前和之后，通知所有观察对象属性值的更改情况。</p>
<p><strong>NSKVONotifying_A类剖析：</strong></p>
<p>在这个过程中，被观察对象的isa指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类NSKVONotifying_A类，来实现当前类属性值改变的监听。</p>
<p>所以当我们从应用层面看来，完全没有意识到新类的出现，这个系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时我们如果创建一个新的类名为“NSKVONotifying_A”的类，就会发现系统运行到注册注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向了这个中间类。        </p>
<p>（isa 指针的作用：每个对象都有 isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa 指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。</p>
<p><strong>子类setter方法剖析：</strong></p>
<p>KVO的键值观察通知依赖NSObject的两个方法：willChangeValueForKey:和didChangeValueForKey:，在存取数值的前后分别调用了2个方法：被观察属性发生改变前，willchangeValueForKey:被调用，通知系统该keyPath的属性值即将变更；当改变发生后，didChangeValueForKey:被调用，通知系统该keyPath的属性值已经变更，之后，observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter方法这种继承方式的注入是在运行时而不是编译时实现的。</p>
<p>KVO为子类的观察属性重写调用存取方法的工作原理在代码中相当于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)setName:(NSString *)newName&#123;</span><br><span class="line">  [self willChangeValueForKey:@&quot;name&quot;];             //KVO 在调用存取方法之前总调用 </span><br><span class="line">  [super setValue:newName forKey:@&quot;name&quot;];          //调用父类的存取方法 </span><br><span class="line">  [self didChangeValueForKey:@&quot;name&quot;];              //KVO 在调用存取方法之后总调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>特点：</strong></p>
<p>察者观察的是属性，只有遵循 KVO 变更属性值的方式才会执行 KVO 的回调方法，例如是否执行了 setter 方法、或者是否使用了 KVC 赋值。<br>如果赋值没有通过 setter 方法或者 KVC，而是直接修改属性对应的成员变量，例如：仅调用 _name = @”newName”，这时是不会触发 KVO 机制，更加不会调用回调方法的。<br>所以使用 KVO 机制的前提是遵循 KVO 的属性设置方式来变更属性值。</p>
<h2 id="3-项目应用"><a href="#3-项目应用" class="headerlink" title="3.项目应用"></a>3.项目应用</h2><p><strong>步骤：</strong><br>1.注册观察者，实施监听<br>2.在回调方法中处理属性发生的变化<br>3.移除观察者</p>
<p><strong>1.注册观察者</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数 observer：观察者 （这里观察self.myKVO对象的属性变化） </span><br><span class="line">//第二个参数 keyPath： 被观察的属性名称(这里观察 self.myKVO 中 num 属性值的改变) </span><br><span class="line">//第三个参数 options： 观察属性的新值、旧值等的一些配置（枚举值，可以根据需要设置，例如这里可以使用两项）</span><br><span class="line"> //第四个参数 context： 上下文，可以为 KVO 的回调方法传值（例如设定为一个放置数据的字典）</span><br><span class="line"></span><br><span class="line"> [self.myKVO addObserver:self forKeyPath:@&quot;num&quot; options: NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure>
<p><strong>2.属性（keyPath）的值发生变化时，收到通知，调用一下方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//keyPath:属性名称 </span><br><span class="line">//object:被观察的对象 </span><br><span class="line">//change:变化前后的值都存储在 change 字典中 </span><br><span class="line">//context:注册观察者时，context 传过来的值 </span><br><span class="line"></span><br><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.移除观察者</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.myKVO removeObserver:self forKeyPath:@&quot;num&quot; context:nil];</span><br></pre></td></tr></table></figure></p>
<h2 id="4-拓展："><a href="#4-拓展：" class="headerlink" title="4. 拓展："></a>4. 拓展：</h2><p><strong>1.KVC与KVO的不同</strong></p>
<p>KVC（键值编码），即Key-Value-Coding，一个非正式的Protocol，使用字符串（键）访问一个对象实例变量的机制，而不是通过调用setter、getter方法等显式的存取方法去访问。</p>
<p>KVO（键值监听），即Key-Value Observing，它提供一种机制，当指定的对象的属性被修改后，对象就会接受到通知，前提是执行了setter方法，或者使用了KVC赋值。</p>
<p><strong>2.和notification（通知）的区别</strong></p>
<p>notification比KVO多了发送通知的一步。<br>两者都是一对多，但是对象之间直接的交互，notification明显得多，需要notificationCenter来做中间交互，而KVO如我们介绍的，设置观察者 -&gt; 处理属性变化， 至于中间通知这一环，则隐秘得多。</p>
<p>Notification 的优点是不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，例如键盘，前台后台等系统通知的使用也更显灵活方便。</p>
<p><strong>3.与delegate的不同</strong></p>
<p>和delegate一样，KVO和NSNotificaiton的作用都是类于类之间的通信，但是与delegate不同的是：两个都是负责发送接收通知，剩余的事情有系统处理，所以不用返回值；而delegate 则需要通信的对象通过变量（代理）联系。<br>delegate一般是一对一，而这两个可以以对多。</p>
<p><strong>4.涉及技术</strong></p>
<p>KVC／KVO实现的根本是 Objective-C的动态性和Runtime，以及访问方法的实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/23/2018-03-23-谈谈KVO的实现原理/" data-id="cjoquoco30003ij4447okske9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-03-23-iOS开发笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/06/2018-03-23-iOS开发笔记/" class="article-date">
  <time datetime="2017-01-05T16:00:00.000Z" itemprop="datePublished">2017-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/06/2018-03-23-iOS开发笔记/">开发笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="开发笔记"><a href="#开发笔记" class="headerlink" title="开发笔记"></a>开发笔记</h2><h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h3><p><strong>路径：/ private / etc /</strong></p>
<p><strong>命令行操作：<br>sudo vi /etc/hosts 打开host文件修改</strong></p>
<h3 id="1-UILabel、UIButton文字显示不全时，省略号显示位置"><a href="#1-UILabel、UIButton文字显示不全时，省略号显示位置" class="headerlink" title="1.UILabel、UIButton文字显示不全时，省略号显示位置"></a>1.UILabel、UIButton文字显示不全时，省略号显示位置</h3><pre>
abel.lineBreakMode = NSLineBreakByCharWrapping;以字符为显示单位显示，后面部分省略不显示。

label.lineBreakMode = NSLineBreakByClipping;剪切与文本宽度相同的内容长度，后半部分被删除。
label.lineBreakMode = NSLineBreakByTruncatingHead;前面部分文字以……方式省略，显示尾部文字内容。
label.lineBreakMode = NSLineBreakByTruncatingMiddle;中间的内容以……方式省略，显示头尾的文字内容。
label.lineBreakMode = NSLineBreakByTruncatingTail;结尾部分的内容以……方式省略，显示头的文字内容。
label.lineBreakMode = NSLineBreakByWordWrapping;以单词为显示单位显示，后面部分省略不显示。
</pre>

<h3 id="2-点击事件冲突"><a href="#2-点击事件冲突" class="headerlink" title="2.点击事件冲突"></a>2.点击事件冲突</h3><pre>
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch {
    if ([NSStringFromClass([touch.view class]) isEqualToString:@"UITableViewCellContentView"]) {
        return NO;
    }else {
        return YES;
    }
}

</pre>

<h3 id="3-单元测试断言及解析"><a href="#3-单元测试断言及解析" class="headerlink" title="3.单元测试断言及解析"></a>3.单元测试断言及解析</h3><pre>
XCTFail(format…) 生成一个失败的测试； 
XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过；
XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；
XCTAssert(expression, format...)当expression求值为TRUE时通过；
XCTAssertTrue(expression, format...)当expression求值为TRUE时通过；
XCTAssertFalse(expression, format...)当expression求值为False时通过；
XCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；
XCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；
XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用, 判断的是变量的地址，如果地址相同则返回TRUE，否则返回NO）；
XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；
XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；
XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；
XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；
XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；
XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；
XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；
XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过

作者：登低自高
链接：http://www.jianshu.com/p/009844a0b9ed
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</pre>

<h3 id="4-如何解决cell上有textfieldh和其他可点击控价的点击事件冲突"><a href="#4-如何解决cell上有textfieldh和其他可点击控价的点击事件冲突" class="headerlink" title="4.如何解决cell上有textfieldh和其他可点击控价的点击事件冲突"></a>4.如何解决cell上有textfieldh和其他可点击控价的点击事件冲突</h3><p><strong>冲突有三个：</strong></p>
<ul>
<li>1.cell的点击事件；</li>
<li>2.textfield的店家事件</li>
<li>3.其他控件的点击事件</li>
</ul>
<p><a href="http://203.81.21.2:8888/getSupplyInfo.php?page=2&amp;pagesize=10&amp;industry=1458&amp;commodity=1&amp;twoCommodity=320&amp;SuppCode=2102" target="_blank" rel="noopener">http://203.81.21.2:8888/getSupplyInfo.php?page=2&amp;pagesize=10&amp;industry=1458&amp;commodity=1&amp;twoCommodity=320&amp;SuppCode=2102</a></p>
<p><a href="http://203.81.21.2:8888/getSupplyList.php?&amp;custid=15814555032" target="_blank" rel="noopener">http://203.81.21.2:8888/getSupplyList.php?&amp;custid=15814555032</a></p>
<p><a href="http://203.81.21.2:8888/pubSupply.php?InfoTitle=供应测试32&amp;ProductName=坯料&amp;industry=1458&amp;commodity=1&amp;twoCommodity=320&amp;Address=广东省广州市荔湾区&amp;ProductPrice=" target="_blank" rel="noopener">http://203.81.21.2:8888/pubSupply.php?InfoTitle=供应测试32&amp;ProductName=坯料&amp;industry=1458&amp;commodity=1&amp;twoCommodity=320&amp;Address=广东省广州市荔湾区&amp;ProductPrice=</a> &amp;ProductSpec=12&amp;SupplyAmount=12&amp;ProductUnit=吨&amp;Manufacturer=宝钢&amp;CompName=中华商务网&amp;ProductKeyword=坯料&amp;SupplyEndDate=2017-07-20&amp;ProuctDetails=描述测试&amp;suppCode=2102&amp;custid=15814555032&amp;token=15814555032412c3ae22008a92eeaaa82a0bac88807tsTlrdXpMyR</p>
<h2 id="2017-11-3"><a href="#2017-11-3" class="headerlink" title="2017-11-3"></a>2017-11-3</h2><h3 id="1-给view添加阴影效果"><a href="#1-给view添加阴影效果" class="headerlink" title="1.给view添加阴影效果"></a>1.给view添加阴影效果</h3><pre>
    //设置阴影的颜色
    _knobView.layer.shadowColor = [UIColor darkGrayColor].CGColor;
    //设置阴影偏移，X向右偏移2，Y不变
    _knobView.layer.shadowOffset = CGSizeMake(2, 0);
    //设置阴影的透明度
    _knobView.layer.shadowOpacity = 0.4;
    //设置阴影的半径
    _knobView.layer.shadowRadius = 0.5;
</pre>

<h2 id="2017-11-6"><a href="#2017-11-6" class="headerlink" title="2017-11-6"></a>2017-11-6</h2><h3 id="颜色渐变"><a href="#颜色渐变" class="headerlink" title="颜色渐变"></a>颜色渐变</h3><p>[参考]（<a href="http://www.jianshu.com/p/3e0e25fd9b85）" target="_blank" rel="noopener">http://www.jianshu.com/p/3e0e25fd9b85）</a></p>
<pre>
 CAGradientLayer *gradientLayer = [CAGradientLayer layer];
    gradientLayer.colors = @[(__bridge id)[self stringToColor:@"#16a9b3"].CGColor, (__bridge id)[self stringToColor:@"#126ac4"].CGColor];
    gradientLayer.locations = @[@0.0, @1.0];
    gradientLayer.startPoint = CGPointMake(0, 0);
    gradientLayer.endPoint = CGPointMake(0, 1.0);
    gradientLayer.frame = self.view.bounds;
    [self.view addSublayer:gradientLayer];
</pre>


<ul>
<li>1.colors 渐变的颜色</li>
<li>2.locations 渐变颜色的分割点</li>
<li>3.startPoint&amp;endPoint 颜色渐变的方向，范围在(0,0)与(1.0,1.0)之间，如(0,0)(1.0,0)代表水平方向渐变,(0,0)(0,1.0)代表竖直方向渐变</li>
</ul>
<h2 id="2017-12-7"><a href="#2017-12-7" class="headerlink" title="2017-12-7"></a>2017-12-7</h2><h3 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h3><pre>
//状态栏高度
#define STATUS_BAR_HEIGHT 20
//NavBar高度
#define NAVIGATION_BAR_HEIGHT 44
//状态栏 ＋ 导航栏 高度
#define STATUS_AND_NAVIGATION_HEIGHT  ((STATUS_BAR_HEIGHT) + (NAVIGATION_BAR_HEIGHT))

//屏幕 rect
#define SCREEN_RECT ([UIScreen mainScreen].bounds)
//屏幕宽度
#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)
//屏幕高度
#define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height)
#define CONTENT_HEIGHT (SCREEN_HEIGHT - NAVIGATION_BAR_HEIGHT - STATUS_BAR_HEIGHT)
//屏幕分辨率
#define SCREEN_RESOLUTION (SCREEN_WIDTH * SCREEN_HEIGHT * ([UIScreen mainScreen].scale))


//获取系统版本         
#define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue] 
#define CurrentSystemVersion [[UIDevice currentDevice] systemVersion] 

//获取系统时间戳
#define getCurentTime [NSString stringWithFormat:@"%ld", (long)[[NSDate date] timeIntervalSince1970]]

//判断是真机还是模拟器
#if TARGET_OS_IPHONE
//真机
#endif
#if TARGET_IPHONE_SIMULATOR
//模拟器
#endif

//获取当前语言  
#define CurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])


//rgb颜色转换（16进制->10进制）  
#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16))/255.0 green:((float)((rgbValue & 0xFF00) >> 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0]  

//获取RGB颜色  
#define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]  
#define RGB(r,g,b) RGBA(r,g,b,1.0f)

//读取本地图片  
#define LOADIMAGE(file,ext) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle]pathForResource:file ofType:ext]]  

//定义UIImage对象  
#define IMAGE(A) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle] pathForResource:A ofType:nil]]
//DEBUG模式下打印日志,当前行  
#ifdef  DEBUG  
#define DLog(fmt, ...) NSLog((@"%s [Line %d] " fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);  
#else  
#define DLog(...)  
#endif 

//主要单例
#define UserDefaults [NSUserDefaults standardUserDefaults]
#define NotificationCenter [NSNotificationCenter defaultCenter]
#define SharedApplication [UIApplication sharedApplication]
#define Bundle [NSBundle mainBundle]#define MainScreen [UIScreen mainScreen]

//角度转弧度
#define DEGREES_TO_RADIANS(d) (d * M_PI / 180)


//文件目录
#define kPathTemp           NSTemporaryDirectory()
#define kPathDocument       [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]
#define kPathCache          [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) objectAtIndex:0]
#define kPathSearch         [kPathDocument  stringByAppendingPathComponent:@"Search.plist"]
#define kPathMagazine       [kPathDocument stringByAppendingPathComponent:@"Magazine"]
#define kPathDownloadedMgzs [kPathMagazine stringByAppendingPathComponent:@"DownloadedMgz.plist"]
#define kPathDownloadURLs   [kPathMagazine stringByAppendingPathComponent:@"DownloadURLs.plist"]
#define kPathOperation      [kPathMagazine stringByAppendingPathComponent:@"Operation.plist"]
#define kPathSplashScreen   [kPathCache stringByAppendingPathComponent:@"splashScreen"]

//GCD - 一次性执行
#define DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&onceToken, onceBlock);

//GCD - 在Main线程上运行
#define DISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock);

//GCD - 开启异步线程
#define DISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl);



</pre>

<p><a href="http://www.jianshu.com/p/4f19c49bf6d9?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" target="_blank" rel="noopener">宏定义的黑魔法
</a></p>
<p>##2017-12-12<br>1.SVN删除分支文件夹，在提交时遇到过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Commit filed(details follow):Directory &apos;xxx&apos; is out of date</span><br></pre></td></tr></table></figure>
<p><strong>处理方法：</strong></p>
<p>在此文件update一下再Commit即可成功</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/06/2018-03-23-iOS开发笔记/" data-id="cjoquocoy001cij44ln99r9b0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/加密/">加密</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/哈希/">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字典/">字典</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/底层/">底层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/加密/" style="font-size: 10px;">加密</a> <a href="/tags/哈希/" style="font-size: 10px;">哈希</a> <a href="/tags/字典/" style="font-size: 10px;">字典</a> <a href="/tags/底层/" style="font-size: 15px;">底层</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/笔记/" style="font-size: 20px;">笔记</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/11/19/2018-11-19-NSOperationQueue-线程同步/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/11/05/iOS-自定义转场效果/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/10/10/2018-10-10-iOS之图片缓存/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/09/19/2018-09-18-iOS性能优化/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 耀敬业<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>